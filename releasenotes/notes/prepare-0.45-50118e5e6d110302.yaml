---
prelude: |
  Qiskit 0.45.0 is the last feature release before 1.0. It prepares the ground for the API
  changes we are planning for our first major version release, including many removals of
  previously deprecated functionality as well as a series of new deprecations.

  .. note::
    If your project depends on Qiskit, it may rely on functionality that will no longer
    be supported in Qiskit 1.0. For this reason, we recommend that you proactively cap your
    supported version to ``<1.0``.

  Some feature highlights of Qiskit 0.45.0 are:

  * Starting in this release, all unparametrized gates in the Qiskit standard circuit library are now
    **singletons**. By default, these gates share a single instance in memory, so once a gate of a
    specific type, let's say :class:`.XGate`, is instantiated, any subsequent instances of
    :class:`.XGate` will be a reference to the first one. This results in a reduced memory usage and
    construction overhead when using multiple gates of the same type in a circuit.
    To realize this feature, new base classes have been
    introduced: :class:`.SingletonInstruction` and :class:`.SingletonGate`. See feature notes for more details.

  * We have added a new **generic pass manager interface** that can be found in the new
    :mod:`qiskit.passmanager` module. This is a generalization of the pass manager that was used to build the
    Qiskit transpiler, and it introduces a generic framework to enable users to create new pass managers
    that use different intermediate representations (IRs). The module includes a generic pass manager base class,
    flow controllers, and the necessary infrastructure to manage the execution of pass manager tasks.
    The new interface was used to rebuild the existing pass manager in the :mod:`qiskit.transpiler` module,
    cleaning up technical debt in the code, and improving usability and performance.
    See feature and upgrade notes for more details.

  * 0.45.0 allows users to better interact with the **layout permutations** performed by the transpiler. The data
    contained in the :class:`.TranspileLayout` class is now more accessible through a series of new methods
    and attributes. And a new :meth:`.SparsePauliOp.apply_layout` method allows to apply a specific layout
    permutation to a :class:`~.SparsePauliOp` observable that was built for an input circuit to the transpiler.
    See feature notes for more details.

  * Finally, we have introduced **annotated operations** with the new :class:`.AnnotatedOperation` class,
    which allows to formulate complex circuit instructions as a base instruction with a set of modifiers.
    For example, instead of a specific operation type that implements the controlled inverse of a
    :class:`.RXGate`, we can now use an annotated :class:`.RXGate` with inverse and control attributes.
    See feature notes for more details.
